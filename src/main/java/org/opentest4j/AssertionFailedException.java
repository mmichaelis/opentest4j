/*
 * Copyright 2015-2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.opentest4j;

import static org.opentest4j.debug.DebugInformation.builder;
import static org.opentest4j.debug.DebugInformationDefaultKey.ACTUAL;
import static org.opentest4j.debug.DebugInformationDefaultKey.EXPECTED;

import org.opentest4j.debug.DebugInformation;
import org.opentest4j.debug.ValueDescriptor;

/**
 * {@code AssertionFailedError} is an <em>initial draft</em> for a common base class for test-related
 * {@link AssertionError AssertionErrors}.
 * <p>
 * In addition to a message and a cause this class stores the expected and actual values of an assertion using the
 * {@link ValueDescriptor} type.
 * <p>
 * <strong>WARNING</strong>: this is a <em>work in progress</em> and is therefore guaranteed to undergo heavy revisions
 * in the near future based on community feedback.
 *
 * @author Sam Brannen
 * @author Marc Philipp
 * @since 1.0
 */
public class AssertionFailedException extends DebuggableException {

	private static final long serialVersionUID = 1L;

	/**
	 * Constructs an {@code AssertionFailedError} with no message, no cause, and no expected/actual values.
	 */
	public AssertionFailedException() {
	}

	/**
	 * Constructs an {@code AssertionFailedError} with a message, no cause, and no expected/actual values.
	 */
	public AssertionFailedException(String message) {
		super(message);
	}

	public AssertionFailedException(Throwable cause) {
		super(cause);
	}

	public AssertionFailedException(DebugInformation debugInformation) {
		super(debugInformation);
	}

	public AssertionFailedException(String message, DebugInformation debugInformation) {
		super(message, debugInformation);
	}

	public AssertionFailedException(String message, DebugInformation debugInformation, Throwable cause) {
		super(message, debugInformation, cause);
	}

	public AssertionFailedException(DebugInformation debugInformation, Throwable cause) {
		super(debugInformation, cause);
	}

	/**
	 * Constructs an {@code AssertionFailedError} with a message and expected/actual values but without a cause.
	 */
	public AssertionFailedException(String message, Object expected, Object actual) {
		this(message,
		      builder().put(EXPECTED.getId(), expected).put(ACTUAL.getId(), actual).build());
	}

	/**
	 * Constructs an {@code AssertionFailedError} with a message and a cause but without expected/actual values.
	 */
	public AssertionFailedException(String message, Throwable cause) {
		super(message, cause);
	}

	/**
	 * Constructs an {@code AssertionFailedError} with a message, expected/actual values, and a cause.
	 */
	public AssertionFailedException(String message, Object expected, Object actual, Throwable cause) {
		this(message,
		      builder().put(EXPECTED.getId(), expected).put(ACTUAL.getId(), actual).build(),
		      cause);
	}

	/**
	 * Returns {@code true} if the expected value is defined, i.e. was passed to the constructor.
	 *
	 * @see #getExpected()
	 */
	public boolean isExpectedDefined() {
		return hasDebugInformation() && getDebugInformation().containsKey(EXPECTED.getId());
	}

	/**
	 * Returns {@code true} if the actual value is defined, i.e. was passed to the constructor.
	 *
	 * @see #getActual()
	 */
	public boolean isActualDefined() {
		return hasDebugInformation() && getDebugInformation().containsKey(ACTUAL.getId());
	}

	/**
	 * Returns the wrapped expected value if it is defined; otherwise {@code null}.
	 *
	 * @see #isExpectedDefined()
	 */
	public ValueDescriptor getExpected() {
		return isExpectedDefined() ? getDebugInformation().get(EXPECTED.getId()) : null;
	}

	/**
	 * Returns the wrapped actual value if it is defined; otherwise {@code null}.
	 *
	 * @see #isActualDefined()
	 */
	public ValueDescriptor getActual() {
		return isActualDefined() ? getDebugInformation().get(ACTUAL.getId()) : null;
	}

}
